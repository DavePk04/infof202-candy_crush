#include "Board.hpp"
#include <algorithm>
#include <unordered_set>
#include<set>

using namespace std;


vector<int> delete_ele(vector<int> vec, int num)
{
  // initializing a reverse iterator
  vector<int>::reverse_iterator itr1;

  for (itr1 = vec.rbegin(); itr1 < vec.rend(); itr1++) {

      if (*itr1 == num) {

//          printf ("élément à supprimer = %i \n", num);
          vec.erase((itr1 + 1).base());
        }
    }

  return vec;
}


int Board::GetColorAt(int row, int col)
{
  if (col < 0 || col >= GRID_DIMENSION
      || row < 0 || row >= GRID_DIMENSION)
    return -1;

  auto color = board[row][col];

  return color;
}


void Board::gen_color_grid ()
{
  for (int i = 0; i < GRID_DIMENSION; i++)
    {
      std::vector<int> copy_color_vect(COLORS_VECT);
      board[i] = new int[GRID_DIMENSION];
      for (int j = 0; j <= GRID_DIMENSION; j++)
        {
          int left1 = GetColorAt(i, j - 1); //2
          int left2 = GetColorAt(i, j - 2);
          if (left2 != -1 && left1 == left2) // 3
          {
            copy_color_vect = delete_ele (copy_color_vect, left1);
          }

          int down1 = GetColorAt(i - 1, j); // 5
          int down2 = GetColorAt(i - 2, j);
          if (down2 != -1 && down1 == down2)
          {
              copy_color_vect = delete_ele (copy_color_vect, down1);
          }

          int color = copy_color_vect[rand () % copy_color_vect.size ()];
          board[i][j] = color;
        }
    }

}

void print_board(int** data)
{
    for (int x = 0; x < GRID_DIMENSION; x++)
    {
        for (int y = 0; y < GRID_DIMENSION; y++)
        {
            printf(" %d", data[x][y]);       
        }
        printf("\n");
    }
    
}

Board::Board() {
    gen_color_grid();
}


int** Board::getBoard() {
    return board;
}

bool Board::is_inBoard(Point pos) { 
    return (0 <= pos.x and pos.x < GRID_DIMENSION && 0 <= pos.y && pos.y < GRID_DIMENSION);
}


/**
 * This function select Matched cells by Colomn
 * @param row
 * @param col
 * @param color
 * @return
 */
vector<Point> Board::FindColumnMatchForCell(int row, int col, int color)
{
  vector<Point> result;
  for (int i = col + 1; i < GRID_DIMENSION; i++)
    {
      int nextColumnColor = GetColorAt(row, i);
      if (nextColumnColor != color)
        {
          break;
        }
      result.push_back({row,i});
    }
  return result;
}


/**
 * This function select Matched cells by Row
 * @param row
 * @param col
 * @param color
 * @return
 */
vector<Point> Board::FindRowMatchForCell(int row, int col, int color)
{
  vector<Point> result;
  for (int i = row + 1; i < GRID_DIMENSION; i++)
    {
      int nextRowColor = GetColorAt(i, col);
      if (nextRowColor != color)
        {
          break;
        }
      result.push_back({i, col});
    }
  return result;
}


/**
 * This function is used to check if a match appear after a swap
 */
bool Board::CheckMatches(){

  vector<Point> matchedCells;

  for (int row = 0; row < GRID_DIMENSION; row++)
    {
      for (int col = 0; col < GRID_DIMENSION; col++)
        {
          int currentColor = GetColorAt (row, col);

          aligned_candies_H = FindColumnMatchForCell(row, col, currentColor);

          if (aligned_candies_H.size() >= 2)
            {
              for(auto alignedcell: aligned_candies_H)
                {
                  if (count (matchedCells.begin(), matchedCells.end(), alignedcell) == 0)
                    matchedCells.push_back(alignedcell);
                }
              Point to_store{row, col};
              if (count (matchedCells.begin(), matchedCells.end(), to_store) == 0)
                matchedCells.push_back(to_store);
            }

          aligned_candies_V = FindRowMatchForCell(row, col, currentColor);

          if (aligned_candies_V.size() >= 2)
            {
              for(auto alignedcell: aligned_candies_V)
                {
                  if (count (matchedCells.begin(), matchedCells.end(), alignedcell) == 0)
                    matchedCells.push_back(alignedcell);
                }

              Point to_store{row, col};
              if (count (matchedCells.begin(), matchedCells.end(), to_store) == 0)
                matchedCells.push_back(to_store); // 5
            }
        }
    }

    for(auto CellToDelete:matchedCells)
      board[CellToDelete.x][CellToDelete.y] = -1;

  return matchedCells.size() > 0;

}

/**
 * This function drop cells and generate new ones
 */
void Board::FillGrid(){
  for (int col = 0; col < GRID_DIMENSION; col++)
    {
      for (int row = 0; row < GRID_DIMENSION; row++)
        {
          while (GetColorAt (row, col) == -1) {
              for (int toFill = row; toFill > 0; toFill--)
                {
                  board[toFill][col] = GetColorAt (toFill-1,col);
                }

              board[0][col] = COLORS_VECT[rand() % TOTALCOLOR];
          }
        }
    }
}


/**
* method called when a swap is done 
*/
void Board::swap(Point cell_1, Point cell_2) {

  int tmp = board[cell_2.x][cell_2.y];
  board[cell_2.x][cell_2.y] = board[cell_1.x][cell_1.y];
  board[cell_1.x][cell_1.y] = tmp;

  bool changesOccurs = CheckMatches();

  if(!changesOccurs)
    {
      tmp = board[cell_1.x][cell_1.y];
      board[cell_1.x][cell_1.y] = board[cell_2.x][cell_2.y];
      board[cell_2.x][cell_2.y] = tmp;
    }
  else
    {
      do
        {
          FillGrid();
        }
      while (CheckMatches());
    }

  print_board(board);
}


int main(){
    Board bd;
    int** board = bd.getBoard();
    print_board(board);
    printf("-----------\n");
//     bd.swap(Point{0,6}, Point{0,5});
//     printf("-----------\n");
     bd.swap(Point{0,6}, Point{1,6});
  printf("-----------\n");
     bd.swap(Point{2,7}, Point{2,6});
    // bd.swap(Point{1,0}, Point{1,1});
    printf("-----------\n");
    //bd.swap(Point{7,1}, Point{8,1});
    //bd.swap(Point{2,6}, Point{3,6});
    // bd.swap(Point{8,8}, Point{8,7});
    // vector<Point> vector1 = {Point{8,0}, Point{8,1}, Point{8,2}};
    // vector<Point> vector2 = {Point{3,6}, Point{4,6}, Point{5,6}};
    // bd.delete_candies(vector2);
    // printf("-----------\n");
    // print_board(board);
}
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































